<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>mesh2plan v1</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; color: #eee; font-family: system-ui, sans-serif; overflow: hidden; }
canvas { display: block; }

#controls {
  position: absolute; top: 16px; left: 16px; z-index: 10;
  background: rgba(20, 20, 40, 0.92); border-radius: 12px; padding: 16px;
  min-width: 220px; backdrop-filter: blur(10px);
  border: 1px solid rgba(255,255,255,0.1);
}
#controls h2 { font-size: 13px; margin-bottom: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; }

.layer { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; cursor: pointer; font-size: 13px; }
.layer input { cursor: pointer; }
.layer label { cursor: pointer; flex: 1; }
.dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
.sep { border-top: 1px solid rgba(255,255,255,0.08); margin: 10px 0; }

.srow { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; font-size: 12px; }
.srow label { min-width: 65px; color: #888; }
.srow input[type=range] { flex: 1; }

#info {
  position: absolute; bottom: 16px; left: 16px; z-index: 10;
  background: rgba(20, 20, 40, 0.9); border-radius: 8px; padding: 10px 14px;
  font-size: 12px; color: #888; backdrop-filter: blur(8px);
  border: 1px solid rgba(255,255,255,0.08);
}

#loading {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 100;
  display: flex; align-items: center; justify-content: center;
  background: #1a1a2e; font-size: 14px; color: #666;
}
#loading.hidden { display: none; }
</style>
</head>
<body>

<div id="loading">Loading mesh + texture...</div>

<div id="controls">
  <h2>mesh2plan v1</h2>
  <div id="layers"></div>
  <div class="sep"></div>
  <div class="srow"><label>Mesh</label><input type="range" id="meshOpacity" min="0" max="100" value="80"></div>
  <div class="srow"><label>Planes</label><input type="range" id="planeOpacity" min="0" max="100" value="50"></div>
  <div class="srow"><label>Wireframe</label><input type="checkbox" id="wireframe"></div>
</div>
<div id="info">Loading...</div>

<script type="importmap">
{ "imports": {
  "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
}}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

const DATA = '../data/room_scan/2026_02_09_19_03_38/';

const COLORS = {
  floor:   { hex: 0x4CAF50, css: '#4CAF50' },
  ceiling: { hex: 0x2196F3, css: '#2196F3' },
  wall:    { hex: 0xFF9800, css: '#FF9800' },
  unknown: { hex: 0x9C27B0, css: '#9C27B0' },
};

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e);
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 200);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const dl = new THREE.DirectionalLight(0xffffff, 0.6);
dl.position.set(5, 8, 5);
scene.add(dl);

const grid = new THREE.GridHelper(20, 40, 0x333355, 0x222244);
scene.add(grid);
const axes = new THREE.AxesHelper(1);
scene.add(axes);

const meshGroup = new THREE.Group();
scene.add(meshGroup);
const planeGroups = {};

const info = document.getElementById('info');
let meshCenter = new THREE.Vector3();
let floorY = 0;

// Load textured OBJ
const mtlLoader = new MTLLoader();
mtlLoader.setPath(DATA);
mtlLoader.load('textured_output.mtl', (materials) => {
  materials.preload();
  
  const objLoader = new OBJLoader();
  objLoader.setMaterials(materials);
  objLoader.setPath(DATA);
  objLoader.load('textured_output.obj', (obj) => {
    // Center mesh
    const box = new THREE.Box3().setFromObject(obj);
    meshCenter = box.getCenter(new THREE.Vector3());
    obj.position.sub(meshCenter);
    
    const box2 = new THREE.Box3().setFromObject(obj);
    floorY = box2.min.y;
    obj.position.y -= floorY;
    
    const size = box2.getSize(new THREE.Vector3());
    
    // Make materials transparent-capable
    obj.traverse(c => {
      if (c.isMesh && c.material) {
        c.material.transparent = true;
        c.material.opacity = 0.8;
        c.material.side = THREE.DoubleSide;
      }
    });
    meshGroup.add(obj);

    // Camera
    const maxDim = Math.max(size.x, size.y, size.z);
    controls.target.set(0, size.y / 2, 0);
    camera.position.set(maxDim * 0.8, size.y * 0.8, maxDim * 0.8);
    controls.update();

    let vc = 0;
    obj.traverse(c => { if (c.isMesh) vc += c.geometry.attributes.position.count; });
    info.textContent = `${vc.toLocaleString()} verts | ${size.x.toFixed(1)} × ${size.y.toFixed(1)} × ${size.z.toFixed(1)}m | Drag to orbit`;
    
    document.getElementById('loading').classList.add('hidden');
    loadPlanes();
  },
  (xhr) => {
    if (xhr.total) {
      const pct = (xhr.loaded / xhr.total * 100).toFixed(0);
      document.getElementById('loading').textContent = `Loading mesh... ${pct}%`;
    }
  });
});

async function loadPlanes() {
  try {
    const resp = await fetch('../output/planes_room.json');
    const data = await resp.json();
    buildGeometry(data.planes);
    buildUI(data.planes);
  } catch(e) {
    console.warn('No planes data:', e);
  }
}

function buildGeometry(planes) {
  for (const plane of planes) {
    const type = plane.type;
    if (!planeGroups[type]) {
      planeGroups[type] = new THREE.Group();
      scene.add(planeGroups[type]);
    }

    const boundary = plane.boundary;
    if (!boundary || boundary.length < 3) continue;

    const centroid = new THREE.Vector3(...plane.centroid);
    const basisU = new THREE.Vector3(...plane.basis_u);
    const basisV = new THREE.Vector3(...plane.basis_v);
    const color = COLORS[type]?.hex || COLORS.unknown.hex;

    const shape = new THREE.Shape();
    const pts2d = boundary.map(p => {
      const v = new THREE.Vector3(p[0], p[1], p[2]).sub(centroid);
      return new THREE.Vector2(v.dot(basisU), v.dot(basisV));
    });
    shape.moveTo(pts2d[0].x, pts2d[0].y);
    for (let i = 1; i < pts2d.length; i++) shape.lineTo(pts2d[i].x, pts2d[i].y);

    const geom = new THREE.ShapeGeometry(shape);
    const pos = geom.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      const u = pos.getX(i), v = pos.getY(i);
      const p = centroid.clone().add(basisU.clone().multiplyScalar(u)).add(basisV.clone().multiplyScalar(v));
      p.sub(meshCenter);
      p.y -= floorY;
      pos.setXYZ(i, p.x, p.y, p.z);
    }
    geom.computeVertexNormals();

    planeGroups[type].add(new THREE.Mesh(geom, new THREE.MeshPhongMaterial({
      color, transparent: true, opacity: 0.5, side: THREE.DoubleSide, depthWrite: false,
    })));

    const linePts = boundary.map(p => {
      const v = new THREE.Vector3(p[0], p[1], p[2]).sub(meshCenter);
      v.y -= floorY;
      return v;
    });
    planeGroups[type].add(new THREE.Line(
      new THREE.BufferGeometry().setFromPoints(linePts),
      new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.8 })
    ));
  }
}

function buildUI(planes) {
  const el = document.getElementById('layers');
  mkToggle(el, 'mesh', 'Textured Mesh', '#cccccc', true, on => meshGroup.visible = on);
  mkToggle(el, 'grid', 'Grid + Axes', '#444', true, on => { grid.visible = on; axes.visible = on; });

  const counts = {};
  planes.forEach(p => counts[p.type] = (counts[p.type] || 0) + 1);
  for (const [type, group] of Object.entries(planeGroups)) {
    mkToggle(el, type, `${type} (${counts[type]||0})`, COLORS[type]?.css||'#999', true, on => group.visible = on);
  }
}

function mkToggle(parent, id, label, color, checked, fn) {
  const d = document.createElement('div');
  d.className = 'layer';
  d.innerHTML = `<span class="dot" style="background:${color}"></span>
    <input type="checkbox" id="t-${id}" ${checked?'checked':''}>
    <label for="t-${id}">${label}</label>`;
  d.querySelector('input').addEventListener('change', e => fn(e.target.checked));
  parent.appendChild(d);
}

document.getElementById('meshOpacity').addEventListener('input', e => {
  const v = e.target.value/100;
  meshGroup.traverse(c => { if (c.isMesh) c.material.opacity = v; });
});
document.getElementById('planeOpacity').addEventListener('input', e => {
  const v = e.target.value/100;
  Object.values(planeGroups).forEach(g => g.traverse(c => { if (c.isMesh) c.material.opacity = v; }));
});
document.getElementById('wireframe').addEventListener('change', e => {
  meshGroup.traverse(c => { if (c.isMesh) c.material.wireframe = e.target.checked; });
});

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

(function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
})();
</script>
</body>
</html>
