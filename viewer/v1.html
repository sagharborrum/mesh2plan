<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>mesh2plan v1</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; color: #eee; font-family: system-ui, sans-serif; overflow: hidden; }
canvas { display: block; }

#controls {
  position: absolute; top: 16px; left: 16px; z-index: 10;
  background: rgba(20, 20, 40, 0.92); border-radius: 12px; padding: 16px;
  min-width: 220px; backdrop-filter: blur(10px);
  border: 1px solid rgba(255,255,255,0.1);
}
#controls h2 { font-size: 13px; margin-bottom: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; }

.layer { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; cursor: pointer; font-size: 13px; }
.layer input { cursor: pointer; }
.layer label { cursor: pointer; flex: 1; }
.dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
.sep { border-top: 1px solid rgba(255,255,255,0.08); margin: 10px 0; }

.srow { display: flex; align-items: center; gap: 8px; margin-bottom: 5px; font-size: 12px; }
.srow label { min-width: 65px; color: #888; }
.srow input[type=range] { flex: 1; }

#info {
  position: absolute; bottom: 16px; left: 16px; z-index: 10;
  background: rgba(20, 20, 40, 0.9); border-radius: 8px; padding: 10px 14px;
  font-size: 12px; color: #888; backdrop-filter: blur(8px);
  border: 1px solid rgba(255,255,255,0.08);
}
</style>
</head>
<body>

<div id="controls">
  <h2>mesh2plan v1</h2>
  <div id="layers"></div>
  <div class="sep"></div>
  <div class="srow"><label>Mesh</label><input type="range" id="meshOpacity" min="0" max="100" value="40"></div>
  <div class="srow"><label>Planes</label><input type="range" id="planeOpacity" min="0" max="100" value="60"></div>
  <div class="srow"><label>Wireframe</label><input type="checkbox" id="wireframe"></div>
</div>
<div id="info">Loading mesh...</div>

<script type="importmap">
{ "imports": {
  "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
}}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

const COLORS = {
  floor:   { hex: 0x4CAF50, css: '#4CAF50' },
  ceiling: { hex: 0x2196F3, css: '#2196F3' },
  wall:    { hex: 0xFF9800, css: '#FF9800' },
  unknown: { hex: 0x9C27B0, css: '#9C27B0' },
};

// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e);
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 100);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dl = new THREE.DirectionalLight(0xffffff, 0.8);
dl.position.set(3, 5, 4);
scene.add(dl);

// Grid on floor (XZ plane, Y-up)
const grid = new THREE.GridHelper(10, 40, 0x333355, 0x222244);
scene.add(grid);

// Axes helper
const axes = new THREE.AxesHelper(0.5);
scene.add(axes);

const meshGroup = new THREE.Group();
scene.add(meshGroup);
const planeGroups = {};

const info = document.getElementById('info');

// Load OBJ and center it
new OBJLoader().load('../data/2026_01_13_14_47_59/export_refined.obj', obj => {
  // Center the mesh at origin
  const box = new THREE.Box3().setFromObject(obj);
  const center = box.getCenter(new THREE.Vector3());
  obj.position.sub(center); // center at origin
  
  // Now recompute box
  const box2 = new THREE.Box3().setFromObject(obj);
  const size = box2.getSize(new THREE.Vector3());
  
  // Move mesh so floor (min Y) sits at Y=0
  obj.position.y -= box2.min.y;

  obj.traverse(c => {
    if (c.isMesh) {
      c.material = new THREE.MeshPhongMaterial({
        color: 0xcccccc, transparent: true, opacity: 0.4,
        side: THREE.DoubleSide, depthWrite: false,
      });
    }
  });
  meshGroup.add(obj);

  // Camera position — view from front-right, looking at center
  const maxDim = Math.max(size.x, size.y, size.z);
  controls.target.set(0, size.y / 2, 0);
  camera.position.set(maxDim * 1.5, size.y * 0.6, maxDim * 1.5);
  controls.update();

  let vc = 0;
  obj.traverse(c => { if (c.isMesh) vc += c.geometry.attributes.position.count; });
  info.textContent = `${vc.toLocaleString()} verts | ${size.x.toFixed(2)} × ${size.y.toFixed(2)} × ${size.z.toFixed(2)}m | Drag to orbit, scroll to zoom`;

  loadPlanes(center, box2.min.y);
});

async function loadPlanes(meshCenter, floorOffset) {
  const resp = await fetch('../output/planes.json');
  const data = await resp.json();
  buildGeometry(data.planes, meshCenter, floorOffset);
  buildUI(data.planes);
}

function buildGeometry(planes, meshCenter, floorOffset) {
  for (const plane of planes) {
    const type = plane.type;
    if (!planeGroups[type]) {
      planeGroups[type] = new THREE.Group();
      scene.add(planeGroups[type]);
    }

    const boundary = plane.boundary;
    if (!boundary || boundary.length < 3) continue;

    const centroid = new THREE.Vector3(...plane.centroid);
    const basisU = new THREE.Vector3(...plane.basis_u);
    const basisV = new THREE.Vector3(...plane.basis_v);
    const color = COLORS[type]?.hex || COLORS.unknown.hex;

    // Filled shape
    const shape = new THREE.Shape();
    const pts2d = boundary.map(p => {
      const v = new THREE.Vector3(p[0], p[1], p[2]).sub(centroid);
      return new THREE.Vector2(v.dot(basisU), v.dot(basisV));
    });
    shape.moveTo(pts2d[0].x, pts2d[0].y);
    for (let i = 1; i < pts2d.length; i++) shape.lineTo(pts2d[i].x, pts2d[i].y);

    const geom = new THREE.ShapeGeometry(shape);
    const pos = geom.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      const u = pos.getX(i), v = pos.getY(i);
      const p = centroid.clone().add(basisU.clone().multiplyScalar(u)).add(basisV.clone().multiplyScalar(v));
      // Apply same transform as mesh: subtract center, adjust floor
      p.sub(meshCenter);
      p.y -= floorOffset;
      pos.setXYZ(i, p.x, p.y, p.z);
    }
    geom.computeVertexNormals();

    planeGroups[type].add(new THREE.Mesh(geom, new THREE.MeshPhongMaterial({
      color, transparent: true, opacity: 0.6, side: THREE.DoubleSide, depthWrite: false,
    })));

    // Outline
    const linePts = boundary.map(p => {
      const v = new THREE.Vector3(p[0], p[1], p[2]).sub(meshCenter);
      v.y -= floorOffset;
      return v;
    });
    planeGroups[type].add(new THREE.Line(
      new THREE.BufferGeometry().setFromPoints(linePts),
      new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.8 })
    ));
  }
}

function buildUI(planes) {
  const el = document.getElementById('layers');
  mkToggle(el, 'mesh', 'OBJ Mesh', '#cccccc', true, on => meshGroup.visible = on);
  mkToggle(el, 'grid', 'Grid', '#444', true, on => { grid.visible = on; axes.visible = on; });

  const counts = {};
  planes.forEach(p => counts[p.type] = (counts[p.type] || 0) + 1);
  for (const [type, group] of Object.entries(planeGroups)) {
    mkToggle(el, type, `${type} (${counts[type]||0})`, COLORS[type]?.css||'#999', true, on => group.visible = on);
  }
}

function mkToggle(parent, id, label, color, checked, fn) {
  const d = document.createElement('div');
  d.className = 'layer';
  d.innerHTML = `<span class="dot" style="background:${color}"></span>
    <input type="checkbox" id="t-${id}" ${checked?'checked':''}>
    <label for="t-${id}">${label}</label>`;
  d.querySelector('input').addEventListener('change', e => fn(e.target.checked));
  parent.appendChild(d);
}

// Controls
document.getElementById('meshOpacity').addEventListener('input', e => {
  meshGroup.traverse(c => { if (c.isMesh) c.material.opacity = e.target.value/100; });
});
document.getElementById('planeOpacity').addEventListener('input', e => {
  const v = e.target.value/100;
  Object.values(planeGroups).forEach(g => g.traverse(c => { if (c.isMesh) c.material.opacity = v; }));
});
document.getElementById('wireframe').addEventListener('change', e => {
  meshGroup.traverse(c => { if (c.isMesh) c.material.wireframe = e.target.checked; });
});

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

(function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
})();
</script>
</body>
</html>
