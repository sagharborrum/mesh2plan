<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>mesh2plan v2 â€” Wall Clustering + Floor Plan</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; color: #eee; font-family: system-ui, sans-serif; overflow: hidden; }
#container { display: flex; width: 100vw; height: 100vh; }
#view3d { flex: 1; position: relative; }
#sidebar { width: 380px; background: #0f0f24; border-left: 1px solid rgba(255,255,255,0.08); display: flex; flex-direction: column; }
#floorplan { flex: 1; position: relative; }
#floorplan canvas { width: 100%; height: 100%; }
#fp-label { position: absolute; top: 12px; left: 12px; font-size: 11px; color: #555; text-transform: uppercase; letter-spacing: 1px; }

#controls {
  position: absolute; top: 16px; left: 16px; z-index: 10;
  background: rgba(15, 15, 36, 0.94); border-radius: 12px; padding: 14px 16px;
  min-width: 220px; backdrop-filter: blur(12px);
  border: 1px solid rgba(255,255,255,0.08);
  max-height: calc(100vh - 80px); overflow-y: auto;
}
#controls h2 { font-size: 12px; margin-bottom: 10px; color: #555; text-transform: uppercase; letter-spacing: 1.5px; }
.layer { display: flex; align-items: center; gap: 6px; margin-bottom: 5px; cursor: pointer; font-size: 12px; }
.layer input { cursor: pointer; }
.layer label { cursor: pointer; flex: 1; }
.dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
.sep { border-top: 1px solid rgba(255,255,255,0.06); margin: 8px 0; }
.srow { display: flex; align-items: center; gap: 6px; margin-bottom: 3px; font-size: 11px; color: #888; }
.srow label { min-width: 55px; }
.srow input[type=range] { flex: 1; }
#info { position: absolute; bottom: 16px; left: 16px; z-index: 10; background: rgba(15,15,36,0.92); border-radius: 8px; padding: 7px 12px; font-size: 11px; color: #666; border: 1px solid rgba(255,255,255,0.06); }
#loading { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 100; display: flex; align-items: center; justify-content: center; background: #1a1a2e; font-size: 14px; color: #666; }
#loading.hidden { display: none; }
#stats { padding: 10px 16px; border-top: 1px solid rgba(255,255,255,0.06); font-size: 11px; color: #555; line-height: 1.8; }
#stats .row { display: flex; justify-content: space-between; }
#stats .val { color: #999; }
</style>
</head>
<body>
<div id="loading">Loading textured mesh...</div>
<div id="container">
  <div id="view3d">
    <div id="controls">
      <h2>mesh2plan v2</h2>
      <div id="layers"></div>
      <div class="sep"></div>
      <div class="srow"><label>Mesh</label><input type="range" id="meshOpacity" min="0" max="100" value="70"></div>
      <div class="srow"><label>Planes</label><input type="range" id="planeOpacity" min="0" max="100" value="45"></div>
      <div class="srow"><label>Wire</label><input type="checkbox" id="wireframe"></div>
    </div>
    <div id="info">Loading...</div>
  </div>
  <div id="sidebar">
    <div id="floorplan"><div id="fp-label">Floor Plan</div><canvas id="fpCanvas"></canvas></div>
    <div id="stats"></div>
  </div>
</div>

<script type="importmap">
{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/" }}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

const DATA = '../data/room_scan/2026_02_09_19_03_38/';
const COLORS = {
  floor: { h: 0x4CAF50, c: '#4CAF50' }, ceiling: { h: 0x2196F3, c: '#2196F3' },
  wall: { h: 0xFF9800, c: '#FF9800' }, unknown: { h: 0x9C27B0, c: '#9C27B0' },
  door: { h: 0xE91E63, c: '#E91E63' }, window: { h: 0x00BCD4, c: '#00BCD4' },
};

const container = document.getElementById('view3d');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e);
const camera = new THREE.PerspectiveCamera(60, 1, 0.01, 200);
const renderer = new THREE.WebGLRenderer({ antialias: true });
container.appendChild(renderer.domElement);
const ctrls = new OrbitControls(camera, renderer.domElement);
ctrls.enableDamping = true; ctrls.dampingFactor = 0.05;

scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const dl = new THREE.DirectionalLight(0xffffff, 0.6); dl.position.set(5, 8, 5); scene.add(dl);
const grid = new THREE.GridHelper(20, 40, 0x333355, 0x222244); scene.add(grid);

const meshGroup = new THREE.Group(); scene.add(meshGroup);
const planeGroups = {};
const openingGroup = new THREE.Group(); scene.add(openingGroup);

let meshCenter = new THREE.Vector3(), floorY = 0, planesData = null;

function resize() {
  const w = container.clientWidth, h = container.clientHeight;
  camera.aspect = w / h; camera.updateProjectionMatrix();
  renderer.setSize(w, h); renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
}
window.addEventListener('resize', () => { resize(); drawFP(); });
resize();

const mtl = new MTLLoader(); mtl.setPath(DATA);
mtl.load('textured_output.mtl', materials => {
  materials.preload();
  const obj = new OBJLoader(); obj.setMaterials(materials); obj.setPath(DATA);
  obj.load('textured_output.obj', o => {
    const box = new THREE.Box3().setFromObject(o);
    meshCenter = box.getCenter(new THREE.Vector3());
    o.position.sub(meshCenter);
    const box2 = new THREE.Box3().setFromObject(o);
    floorY = box2.min.y; o.position.y -= floorY;
    const size = box2.getSize(new THREE.Vector3());
    o.traverse(c => { if (c.isMesh) { c.material.transparent = true; c.material.opacity = 0.7; c.material.side = THREE.DoubleSide; }});
    meshGroup.add(o);
    const mx = Math.max(size.x, size.y, size.z);
    ctrls.target.set(0, size.y/2, 0);
    camera.position.set(mx*0.8, size.y*0.8, mx*0.8);
    ctrls.update();
    let vc = 0; o.traverse(c => { if (c.isMesh) vc += c.geometry.attributes.position.count; });
    document.getElementById('info').textContent = `${vc.toLocaleString()} verts | ${size.x.toFixed(1)}Ã—${size.y.toFixed(1)}Ã—${size.z.toFixed(1)}m`;
    document.getElementById('loading').classList.add('hidden');
    loadPlanes();
  }, xhr => { if (xhr.total) document.getElementById('loading').textContent = `Loading... ${(xhr.loaded/xhr.total*100).toFixed(0)}%`; });
});

async function loadPlanes() {
  const r = await fetch('../output/planes_room_v2.json');
  planesData = await r.json();
  buildGeo(planesData.planes);
  buildUI(planesData.planes);
  drawFP();
  updateStats();
}

function xform(p) {
  const v = new THREE.Vector3(p[0], p[1], p[2]).sub(meshCenter);
  v.y -= floorY; return v;
}

function buildGeo(planes) {
  for (const pl of planes) {
    const t = pl.type;
    if (!planeGroups[t]) { planeGroups[t] = new THREE.Group(); scene.add(planeGroups[t]); }
    const bnd = pl.boundary; if (!bnd || bnd.length < 3) continue;
    const cent = new THREE.Vector3(...pl.centroid);
    const bu = new THREE.Vector3(...pl.basis_u), bv = new THREE.Vector3(...pl.basis_v);
    const color = COLORS[t]?.h || COLORS.unknown.h;

    const shape = new THREE.Shape();
    const p2 = bnd.map(p => { const v = new THREE.Vector3(...p).sub(cent); return new THREE.Vector2(v.dot(bu), v.dot(bv)); });
    shape.moveTo(p2[0].x, p2[0].y);
    p2.slice(1).forEach(p => shape.lineTo(p.x, p.y));
    const geom = new THREE.ShapeGeometry(shape);
    const pos = geom.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      const u = pos.getX(i), v = pos.getY(i);
      const p = cent.clone().add(bu.clone().multiplyScalar(u)).add(bv.clone().multiplyScalar(v));
      const tp = xform(p.toArray()); pos.setXYZ(i, tp.x, tp.y, tp.z);
    }
    geom.computeVertexNormals();
    planeGroups[t].add(new THREE.Mesh(geom, new THREE.MeshPhongMaterial({ color, transparent: true, opacity: 0.45, side: THREE.DoubleSide, depthWrite: false })));
    planeGroups[t].add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(bnd.map(p => xform(p))), new THREE.LineBasicMaterial({ color, opacity: 0.8, transparent: true })));

    // Openings
    for (const op of (pl.openings || [])) {
      if (!op.corners || op.corners.length < 4) continue;
      const oc = COLORS[op.type]?.h || COLORS.door.h;
      openingGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(op.corners.map(p => xform(p))), new THREE.LineBasicMaterial({ color: oc })));
    }
  }
}

function buildUI(planes) {
  const el = document.getElementById('layers');
  mk(el, 'mesh', 'Textured Mesh', '#ccc', true, on => meshGroup.visible = on);
  mk(el, 'grid', 'Grid', '#444', true, on => grid.visible = on);
  const counts = {};
  planes.forEach(p => counts[p.type] = (counts[p.type]||0) + 1);
  for (const [t, g] of Object.entries(planeGroups)) mk(el, t, `${t} (${counts[t]||0})`, COLORS[t]?.c||'#999', true, on => g.visible = on);
  let nd=0, nw=0;
  planes.forEach(p => (p.openings||[]).forEach(o => o.type==='door'? nd++ : nw++));
  if (nd+nw) mk(el, 'openings', `openings (${nd}ðŸšª ${nw}ðŸªŸ)`, COLORS.door.c, true, on => openingGroup.visible = on);
}

function mk(par, id, lbl, col, chk, fn) {
  const d = document.createElement('div'); d.className = 'layer';
  d.innerHTML = `<span class="dot" style="background:${col}"></span><input type="checkbox" id="t-${id}" ${chk?'checked':''}><label for="t-${id}">${lbl}</label>`;
  d.querySelector('input').addEventListener('change', e => fn(e.target.checked)); par.appendChild(d);
}

function updateStats() {
  const p = planesData.planes;
  const w = p.filter(x => x.type==='wall');
  const nO = p.reduce((s,x) => s + (x.openings?.length||0), 0);
  document.getElementById('stats').innerHTML = `
    <div class="row"><span>Planes</span><span class="val">${p.length} (${w.length} walls)</span></div>
    <div class="row"><span>Openings</span><span class="val">${nO}</span></div>
    <div class="row"><span>Floor plan</span><span class="val">${planesData.floor_plan?.wall_lines?.length||0} wall lines</span></div>`;
}

// Floor plan canvas
const fpC = document.getElementById('fpCanvas'), ctx = fpC.getContext('2d');
function drawFP() {
  if (!planesData?.floor_plan) return;
  const fp = planesData.floor_plan;
  const panel = document.getElementById('floorplan');
  const dpr = devicePixelRatio;
  fpC.width = panel.clientWidth * dpr; fpC.height = panel.clientHeight * dpr;
  fpC.style.width = panel.clientWidth + 'px'; fpC.style.height = panel.clientHeight + 'px';
  const w = fpC.width, h = fpC.height;
  ctx.clearRect(0, 0, w, h); ctx.fillStyle = '#0a0a1e'; ctx.fillRect(0, 0, w, h);

  const allPts = [];
  fp.wall_lines.forEach(l => { allPts.push(l.start, l.end); });
  fp.openings.forEach(o => o.corners.forEach(c => allPts.push(c)));
  if (!allPts.length) return;

  const xs = allPts.map(p=>p[0]), ys = allPts.map(p=>p[1]);
  const [mnX, mxX, mnY, mxY] = [Math.min(...xs), Math.max(...xs), Math.min(...ys), Math.max(...ys)];
  const pad = 50*dpr;
  const scale = Math.min((w-2*pad)/(mxX-mnX||1), (h-2*pad)/(mxY-mnY||1));
  const cx = w/2, cy = h/2, midX = (mnX+mxX)/2, midY = (mnY+mxY)/2;
  const tx = p => [cx+(p[0]-midX)*scale, cy+(p[1]-midY)*scale];

  // Walls
  ctx.strokeStyle = COLORS.wall.c; ctx.lineWidth = 3*dpr; ctx.lineCap = 'round';
  for (const l of fp.wall_lines) {
    const [x1,y1] = tx(l.start), [x2,y2] = tx(l.end);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }

  // Openings
  for (const o of fp.openings) {
    const col = o.type === 'door' ? COLORS.door.c : COLORS.window.c;
    ctx.strokeStyle = col; ctx.lineWidth = 2*dpr; ctx.setLineDash([4*dpr, 4*dpr]);
    const pts = o.corners.map(tx);
    ctx.beginPath(); ctx.moveTo(pts[0][0], pts[0][1]);
    pts.slice(1).forEach(p => ctx.lineTo(p[0], p[1])); ctx.stroke();
    ctx.setLineDash([]);
  }

  // Scale bar
  const barPx = 1*scale, barY = h-20*dpr, barX = 20*dpr;
  ctx.strokeStyle = '#555'; ctx.lineWidth = 1.5*dpr;
  ctx.beginPath(); ctx.moveTo(barX, barY); ctx.lineTo(barX+barPx, barY); ctx.stroke();
  ctx.fillStyle = '#555'; ctx.font = `${9*dpr}px system-ui`;
  ctx.fillText('1m', barX+barPx/2-6*dpr, barY+14*dpr);
}

document.getElementById('meshOpacity').addEventListener('input', e => { meshGroup.traverse(c => { if (c.isMesh) c.material.opacity = e.target.value/100; }); });
document.getElementById('planeOpacity').addEventListener('input', e => { const v = e.target.value/100; Object.values(planeGroups).forEach(g => g.traverse(c => { if (c.isMesh) c.material.opacity = v; })); });
document.getElementById('wireframe').addEventListener('change', e => { meshGroup.traverse(c => { if (c.isMesh) c.material.wireframe = e.target.checked; }); });
window.addEventListener('resize', () => { resize(); drawFP(); });

(function animate() { requestAnimationFrame(animate); ctrls.update(); renderer.render(scene, camera); })();
</script>
</body>
</html>
