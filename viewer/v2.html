<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>mesh2plan v2 — Geometry + Floor Plan</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; color: #eee; font-family: system-ui, sans-serif; overflow: hidden; }

#container { display: flex; width: 100vw; height: 100vh; }
#view3d { flex: 1; position: relative; }
#floorplan { width: 350px; background: #12122a; border-left: 1px solid rgba(255,255,255,0.1); position: relative; }
#floorplan canvas { width: 100%; height: 100%; }
#fp-label { position: absolute; top: 12px; left: 12px; font-size: 12px; color: #666; text-transform: uppercase; letter-spacing: 1px; }

#controls {
  position: absolute; top: 16px; left: 16px; z-index: 10;
  background: rgba(20, 20, 40, 0.92); border-radius: 12px; padding: 16px;
  min-width: 240px; backdrop-filter: blur(8px);
  border: 1px solid rgba(255,255,255,0.1);
}
#controls h2 { font-size: 13px; margin-bottom: 12px; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }

.layer { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; cursor: pointer; }
.layer input { cursor: pointer; }
.layer label { cursor: pointer; font-size: 13px; flex: 1; }
.color-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }

.separator { border-top: 1px solid rgba(255,255,255,0.1); margin: 10px 0; }

.slider-row { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
.slider-row label { font-size: 12px; min-width: 70px; }
.slider-row input[type=range] { flex: 1; height: 4px; }

#info {
  position: absolute; bottom: 16px; left: 16px; z-index: 10;
  background: rgba(20, 20, 40, 0.9); border-radius: 8px; padding: 10px 14px;
  font-size: 12px; color: #888; backdrop-filter: blur(8px);
  border: 1px solid rgba(255,255,255,0.1);
}

.tab-bar { display: flex; gap: 0; margin-bottom: 12px; }
.tab { padding: 6px 14px; font-size: 12px; cursor: pointer; background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1); color: #888; }
.tab:first-child { border-radius: 6px 0 0 6px; }
.tab:last-child { border-radius: 0 6px 6px 0; }
.tab.active { background: rgba(255,255,255,0.15); color: #fff; }
</style>
</head>
<body>

<div id="container">
  <div id="view3d">
    <div id="controls">
      <h2>mesh2plan v2</h2>
      <div class="tab-bar">
        <div class="tab active" data-view="3d">3D View</div>
        <div class="tab" data-view="fp">Floor Plan</div>
      </div>
      <div id="layers"></div>
      <div class="separator"></div>
      <div class="slider-row">
        <label>Mesh opacity</label>
        <input type="range" id="meshOpacity" min="0" max="100" value="30">
      </div>
      <div class="slider-row">
        <label>Plane opacity</label>
        <input type="range" id="planeOpacity" min="0" max="100" value="65">
      </div>
      <div class="slider-row">
        <label>Wireframe</label>
        <input type="checkbox" id="wireframe">
      </div>
    </div>
    <div id="info">Loading...</div>
  </div>
  <div id="floorplan">
    <div id="fp-label">Floor Plan</div>
    <canvas id="fpCanvas"></canvas>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

const COLORS = {
  floor:   { hex: 0x4CAF50, css: '#4CAF50' },
  ceiling: { hex: 0x2196F3, css: '#2196F3' },
  wall:    { hex: 0xFF9800, css: '#FF9800' },
  unknown: { hex: 0x9C27B0, css: '#9C27B0' },
  door:    { hex: 0xE91E63, css: '#E91E63' },
  window:  { hex: 0x00BCD4, css: '#00BCD4' },
};

// ── Three.js Setup ──
const container = document.getElementById('view3d');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e);

const camera = new THREE.PerspectiveCamera(60, 1, 0.01, 100);
const renderer = new THREE.WebGLRenderer({ antialias: true });
container.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 5, 5);
scene.add(dirLight);

// Grid helper
const grid = new THREE.GridHelper(10, 40, 0x333355, 0x222244);
scene.add(grid);

const meshGroup = new THREE.Group();
scene.add(meshGroup);
const planeGroups = {};
const openingGroup = new THREE.Group();
scene.add(openingGroup);

let planesData = null;

function resize() {
  const w = container.clientWidth;
  const h = container.clientHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
}
window.addEventListener('resize', () => { resize(); resizeFP(); });
resize();

// ── Load OBJ ──
const info = document.getElementById('info');
new OBJLoader().load('../data/2026_01_13_14_47_59/export_refined.obj', (obj) => {
  obj.traverse(child => {
    if (child.isMesh) {
      child.material = new THREE.MeshPhongMaterial({
        color: 0xcccccc, transparent: true, opacity: 0.3,
        side: THREE.DoubleSide, depthWrite: false,
      });
    }
  });
  meshGroup.add(obj);

  const box = new THREE.Box3().setFromObject(obj);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y, size.z);

  controls.target.copy(center);
  camera.position.copy(center.clone().add(new THREE.Vector3(maxDim * 1.2, maxDim * 0.8, maxDim * 1.2)));
  grid.position.y = box.min.y;
  controls.update();

  let vc = 0;
  obj.traverse(c => { if (c.isMesh) vc += c.geometry.attributes.position.count; });
  info.textContent = `${vc.toLocaleString()} verts | Drag to orbit`;

  loadPlanes();
});

async function loadPlanes() {
  const resp = await fetch('../output/planes_v2.json');
  planesData = await resp.json();
  buildGeometry(planesData.planes);
  buildUI(planesData.planes);
  drawFloorPlan(planesData);
}

function buildGeometry(planes) {
  for (const plane of planes) {
    const type = plane.type;
    if (!planeGroups[type]) {
      planeGroups[type] = new THREE.Group();
      scene.add(planeGroups[type]);
    }

    const boundary = plane.boundary;
    if (!boundary || boundary.length < 3) continue;

    const normal = new THREE.Vector3(...plane.normal);
    const centroid = new THREE.Vector3(...plane.centroid);
    const basisU = new THREE.Vector3(...plane.basis_u);
    const basisV = new THREE.Vector3(...plane.basis_v);

    // Filled polygon
    const shape = new THREE.Shape();
    const pts2d = boundary.map(p => {
      const v = new THREE.Vector3(p[0], p[1], p[2]).sub(centroid);
      return new THREE.Vector2(v.dot(basisU), v.dot(basisV));
    });
    shape.moveTo(pts2d[0].x, pts2d[0].y);
    for (let i = 1; i < pts2d.length; i++) shape.lineTo(pts2d[i].x, pts2d[i].y);

    const shapeGeom = new THREE.ShapeGeometry(shape);
    const positions = shapeGeom.attributes.position;
    for (let i = 0; i < positions.count; i++) {
      const u = positions.getX(i), v = positions.getY(i);
      const p = centroid.clone().add(basisU.clone().multiplyScalar(u)).add(basisV.clone().multiplyScalar(v));
      positions.setXYZ(i, p.x, p.y, p.z);
    }
    shapeGeom.computeVertexNormals();

    const color = COLORS[type]?.hex || COLORS.unknown.hex;
    const mat = new THREE.MeshPhongMaterial({
      color, transparent: true, opacity: 0.65, side: THREE.DoubleSide, depthWrite: false,
    });
    planeGroups[type].add(new THREE.Mesh(shapeGeom, mat));

    // Outline
    const lineGeom = new THREE.BufferGeometry().setFromPoints(
      boundary.map(p => new THREE.Vector3(p[0], p[1], p[2]))
    );
    planeGroups[type].add(new THREE.Line(lineGeom, new THREE.LineBasicMaterial({ color })));

    // Openings
    for (const opening of (plane.openings || [])) {
      if (!opening.corners || opening.corners.length < 4) continue;
      const oColor = COLORS[opening.type]?.hex || COLORS.door.hex;
      const oGeom = new THREE.BufferGeometry().setFromPoints(
        opening.corners.map(p => new THREE.Vector3(p[0], p[1], p[2]))
      );
      openingGroup.add(new THREE.Line(oGeom, new THREE.LineBasicMaterial({ color: oColor, linewidth: 2 })));
      
      // Fill opening rectangle
      const oShape = new THREE.Shape();
      const oPts2d = opening.corners.map(p => {
        const v = new THREE.Vector3(p[0], p[1], p[2]).sub(centroid);
        return new THREE.Vector2(v.dot(basisU), v.dot(basisV));
      });
      oShape.moveTo(oPts2d[0].x, oPts2d[0].y);
      for (let i = 1; i < oPts2d.length; i++) oShape.lineTo(oPts2d[i].x, oPts2d[i].y);

      const oShapeGeom = new THREE.ShapeGeometry(oShape);
      const oPositions = oShapeGeom.attributes.position;
      for (let i = 0; i < oPositions.count; i++) {
        const u = oPositions.getX(i), v = oPositions.getY(i);
        const p = centroid.clone().add(basisU.clone().multiplyScalar(u)).add(basisV.clone().multiplyScalar(v));
        oPositions.setXYZ(i, p.x, p.y, p.z);
      }
      const oMat = new THREE.MeshBasicMaterial({
        color: oColor, transparent: true, opacity: 0.3, side: THREE.DoubleSide, depthWrite: false,
      });
      openingGroup.add(new THREE.Mesh(oShapeGeom, oMat));
    }
  }
}

function buildUI(planes) {
  const layersDiv = document.getElementById('layers');
  
  addToggle(layersDiv, 'mesh', 'OBJ Mesh', '#cccccc', true, on => meshGroup.visible = on);
  addToggle(layersDiv, 'grid', 'Grid', '#333355', true, on => grid.visible = on);
  
  const counts = {};
  planes.forEach(p => counts[p.type] = (counts[p.type] || 0) + 1);

  for (const [type, group] of Object.entries(planeGroups)) {
    const color = COLORS[type]?.css || COLORS.unknown.css;
    addToggle(layersDiv, type, `${type} (${counts[type] || 0})`, color, true, on => group.visible = on);
  }

  // Count openings
  let nDoors = 0, nWindows = 0;
  planes.forEach(p => (p.openings || []).forEach(o => o.type === 'door' ? nDoors++ : nWindows++));
  if (nDoors + nWindows > 0) {
    addToggle(layersDiv, 'openings', `openings (${nDoors}d/${nWindows}w)`, COLORS.door.css, true, on => openingGroup.visible = on);
  }
}

function addToggle(parent, id, label, color, checked, onChange) {
  const div = document.createElement('div');
  div.className = 'layer';
  div.innerHTML = `
    <span class="color-dot" style="background:${color}"></span>
    <input type="checkbox" id="t-${id}" ${checked ? 'checked' : ''}>
    <label for="t-${id}">${label}</label>`;
  div.querySelector('input').addEventListener('change', e => onChange(e.target.checked));
  parent.appendChild(div);
}

// Controls
document.getElementById('meshOpacity').addEventListener('input', e => {
  const v = e.target.value / 100;
  meshGroup.traverse(c => { if (c.isMesh) c.material.opacity = v; });
});
document.getElementById('planeOpacity').addEventListener('input', e => {
  const v = e.target.value / 100;
  Object.values(planeGroups).forEach(g => g.traverse(c => { if (c.isMesh) c.material.opacity = v; }));
});
document.getElementById('wireframe').addEventListener('change', e => {
  meshGroup.traverse(c => { if (c.isMesh) c.material.wireframe = e.target.checked; });
});

// ── Floor Plan (2D Canvas) ──
const fpCanvas = document.getElementById('fpCanvas');
const fpCtx = fpCanvas.getContext('2d');

function resizeFP() {
  const panel = document.getElementById('floorplan');
  fpCanvas.width = panel.clientWidth * devicePixelRatio;
  fpCanvas.height = panel.clientHeight * devicePixelRatio;
  fpCanvas.style.width = panel.clientWidth + 'px';
  fpCanvas.style.height = panel.clientHeight + 'px';
  if (planesData) drawFloorPlan(planesData);
}
resizeFP();

function drawFloorPlan(data) {
  const fp = data.floor_plan;
  if (!fp) return;

  const ctx = fpCtx;
  const w = fpCanvas.width;
  const h = fpCanvas.height;
  const dpr = devicePixelRatio;
  
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = '#12122a';
  ctx.fillRect(0, 0, w, h);

  if (!fp.wall_lines.length) return;

  // Gather all points for bounds
  const allPts = [];
  fp.wall_lines.forEach(l => { allPts.push(l.start, l.end); });
  fp.openings.forEach(o => o.corners.forEach(c => allPts.push(c)));

  const xs = allPts.map(p => p[0]);
  const ys = allPts.map(p => p[1]);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  
  const padding = 60 * dpr;
  const scaleX = (w - 2 * padding) / (maxX - minX || 1);
  const scaleY = (h - 2 * padding) / (maxY - minY || 1);
  const scale = Math.min(scaleX, scaleY);

  const cx = w / 2;
  const cy = h / 2;
  const midX = (minX + maxX) / 2;
  const midY = (minY + maxY) / 2;

  function tx(p) {
    return [
      cx + (p[0] - midX) * scale,
      cy + (p[1] - midY) * scale,
    ];
  }

  // Draw wall lines
  ctx.strokeStyle = COLORS.wall.css;
  ctx.lineWidth = 3 * dpr;
  ctx.lineCap = 'round';
  for (const line of fp.wall_lines) {
    const [x1, y1] = tx(line.start);
    const [x2, y2] = tx(line.end);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  // Draw openings
  for (const opening of fp.openings) {
    const color = opening.type === 'door' ? COLORS.door.css : COLORS.window.css;
    ctx.strokeStyle = color;
    ctx.lineWidth = 2 * dpr;
    ctx.setLineDash([4 * dpr, 4 * dpr]);
    
    const corners = opening.corners.map(tx);
    ctx.beginPath();
    ctx.moveTo(corners[0][0], corners[0][1]);
    for (let i = 1; i < corners.length; i++) {
      ctx.lineTo(corners[i][0], corners[i][1]);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Label
    const labelPt = tx(opening.corners[0]);
    ctx.fillStyle = color;
    ctx.font = `${10 * dpr}px system-ui`;
    ctx.fillText(opening.type, labelPt[0] + 4 * dpr, labelPt[1] - 4 * dpr);
  }

  // Scale bar
  const barLen = 1.0; // 1 meter
  const barPx = barLen * scale;
  const barY = h - 30 * dpr;
  const barX = 30 * dpr;
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2 * dpr;
  ctx.setLineDash([]);
  ctx.beginPath();
  ctx.moveTo(barX, barY);
  ctx.lineTo(barX + barPx, barY);
  ctx.stroke();
  // Ticks
  for (const x of [barX, barX + barPx]) {
    ctx.beginPath();
    ctx.moveTo(x, barY - 5 * dpr);
    ctx.lineTo(x, barY + 5 * dpr);
    ctx.stroke();
  }
  ctx.fillStyle = '#666';
  ctx.font = `${10 * dpr}px system-ui`;
  ctx.fillText('1m', barX + barPx / 2 - 8 * dpr, barY + 18 * dpr);
}

// Tab switching
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    const view = tab.dataset.view;
    document.getElementById('floorplan').style.display = view === 'fp' ? 'block' : (view === '3d' ? 'block' : 'none');
    // Both views visible by default, tabs just for emphasis
  });
});

// Render loop
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
